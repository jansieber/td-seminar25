function varargout=sym_LangKobayashi(action,varargin)
%% Automatically generated with matlabFunction
% 
%#ok<*DEFNU,*INUSD,*INUSL>

switch action
  case 'ntau'
   varargout{1}=1;
   return
  case 'npar'
   varargout{1}=6;
   return
  case 'tp_del'
   varargout{1}=0;
   return
  case 'maxorder'
   varargout{1}=2;
   return
  case 'directional_derivative'
   varargout{1}=1;
   return
end
ind=varargin{1};
order=varargin{2};
nout=varargin{3};
f=str2func(sprintf('sym_LangKobayashi_%s_%d_%d',action,ind,order));
varargout=cell(nout,1);
[varargout{:}]=f(varargin{4:end});
end



function [out1,out2,out3] = sym_LangKobayashi_rhs_1_0(Er,Ei,n,Ertau,Eitau,ntau,pump,eta,phi,tau,alpha,epsilon,Er_d,Ei_d,n_d,Ertau_d,Eitau_d,ntau_d,pump_d,eta_d,phi_d,tau_d,alpha_d,epsilon_d)
%sym_LangKobayashi_rhs_1_0
%    [OUT1,OUT2,OUT3] = sym_LangKobayashi_rhs_1_0(Er,Ei,N,Ertau,Eitau,NTAU,PUMP,ETA,PHI,TAU,ALPHA,EPSILON,Er_d,Ei_d,N_D,Ertau_d,Eitau_d,NTAU_D,PUMP_D,ETA_D,PHI_D,TAU_D,ALPHA_D,EPSILON_D)

%    This function was generated by the Symbolic Math Toolbox version 9.3.
%    09-Apr-2023 01:24:04

t2 = cos(phi);
t3 = sin(phi);
out1 = Er.*n-Ei.*alpha.*n-Eitau.*eta.*t3+Ertau.*eta.*t2;
if nargout > 1
    out2 = Ei.*n+Er.*alpha.*n+Eitau.*eta.*t2+Ertau.*eta.*t3;
end
if nargout > 2
    t4 = Ei.^2;
    t5 = Er.^2;
    out3 = -epsilon.*(n-pump+t4+t5+n.*t4.*2.0+n.*t5.*2.0);
end
end


function [out1,out2,out3] = sym_LangKobayashi_rhs_1_1(Er,Ei,n,Ertau,Eitau,ntau,pump,eta,phi,tau,alpha,epsilon,Er_d,Ei_d,n_d,Ertau_d,Eitau_d,ntau_d,pump_d,eta_d,phi_d,tau_d,alpha_d,epsilon_d)
%sym_LangKobayashi_rhs_1_1
%    [OUT1,OUT2,OUT3] = sym_LangKobayashi_rhs_1_1(Er,Ei,N,Ertau,Eitau,NTAU,PUMP,ETA,PHI,TAU,ALPHA,EPSILON,Er_d,Ei_d,N_D,Ertau_d,Eitau_d,NTAU_D,PUMP_D,ETA_D,PHI_D,TAU_D,ALPHA_D,EPSILON_D)

%    This function was generated by the Symbolic Math Toolbox version 9.3.
%    09-Apr-2023 01:24:05

t2 = cos(phi);
t3 = sin(phi);
out1 = Er_d.*n+Er.*n_d-Ei_d.*alpha.*n-Ei.*alpha_d.*n-Ei.*alpha.*n_d-Eitau.*eta_d.*t3-Eitau_d.*eta.*t3+Ertau.*eta_d.*t2+Ertau_d.*eta.*t2-Eitau.*eta.*phi_d.*t2-Ertau.*eta.*phi_d.*t3;
if nargout > 1
    out2 = Ei_d.*n+Ei.*n_d+Er.*alpha_d.*n+Er_d.*alpha.*n+Er.*alpha.*n_d+Eitau.*eta_d.*t2+Eitau_d.*eta.*t2+Ertau.*eta_d.*t3+Ertau_d.*eta.*t3-Eitau.*eta.*phi_d.*t3+Ertau.*eta.*phi_d.*t2;
end
if nargout > 2
    t4 = Ei.^2;
    t5 = Er.^2;
    out3 = -epsilon.*(n_d-pump_d+n_d.*t4.*2.0+n_d.*t5.*2.0+Ei_d.*Ei.*2.0+Er.*Er_d.*2.0+Ei_d.*Ei.*n.*4.0+Er.*Er_d.*n.*4.0)-epsilon_d.*(n-pump+t4+t5+n.*t4.*2.0+n.*t5.*2.0);
end
end


function [out1,out2,out3] = sym_LangKobayashi_rhs_1_2(Er,Ei,n,Ertau,Eitau,ntau,pump,eta,phi,tau,alpha,epsilon,Er_d,Ei_d,n_d,Ertau_d,Eitau_d,ntau_d,pump_d,eta_d,phi_d,tau_d,alpha_d,epsilon_d)
%sym_LangKobayashi_rhs_1_2
%    [OUT1,OUT2,OUT3] = sym_LangKobayashi_rhs_1_2(Er,Ei,N,Ertau,Eitau,NTAU,PUMP,ETA,PHI,TAU,ALPHA,EPSILON,Er_d,Ei_d,N_D,Ertau_d,Eitau_d,NTAU_D,PUMP_D,ETA_D,PHI_D,TAU_D,ALPHA_D,EPSILON_D)

%    This function was generated by the Symbolic Math Toolbox version 9.3.
%    09-Apr-2023 01:24:05

t2 = cos(phi);
t3 = sin(phi);
t4 = Ei_d.^2;
t5 = Er_d.^2;
t6 = phi_d.^2;
out1 = Er_d.*n_d.*2.0-Ei_d.*alpha_d.*n.*2.0-Ei_d.*alpha.*n_d.*2.0-Ei.*alpha_d.*n_d.*2.0-Eitau_d.*eta_d.*t3.*2.0+Ertau_d.*eta_d.*t2.*2.0-Eitau.*eta_d.*phi_d.*t2.*2.0-Eitau_d.*eta.*phi_d.*t2.*2.0-Ertau.*eta_d.*phi_d.*t3.*2.0-Ertau_d.*eta.*phi_d.*t3.*2.0+Eitau.*eta.*t3.*t6-Ertau.*eta.*t2.*t6;
if nargout > 1
    out2 = Ei_d.*n_d.*2.0+Er_d.*alpha_d.*n.*2.0+Er.*alpha_d.*n_d.*2.0+Er_d.*alpha.*n_d.*2.0+Eitau_d.*eta_d.*t2.*2.0+Ertau_d.*eta_d.*t3.*2.0-Eitau.*eta_d.*phi_d.*t3.*2.0-Eitau_d.*eta.*phi_d.*t3.*2.0+Ertau.*eta_d.*phi_d.*t2.*2.0+Ertau_d.*eta.*phi_d.*t2.*2.0-Eitau.*eta.*t2.*t6-Ertau.*eta.*t3.*t6;
end
if nargout > 2
    out3 = epsilon_d.*(n_d-pump_d+Ei.^2.*n_d.*2.0+Er.^2.*n_d.*2.0+Ei_d.*Ei.*2.0+Er.*Er_d.*2.0+Ei_d.*Ei.*n.*4.0+Er.*Er_d.*n.*4.0).*-2.0-epsilon.*(t4.*2.0+t5.*2.0+n.*t4.*4.0+n.*t5.*4.0+Ei_d.*Ei.*n_d.*8.0+Er.*Er_d.*n_d.*8.0);
end
end

